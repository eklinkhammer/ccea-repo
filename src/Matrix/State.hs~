module Matrix.State
  (
    test
  , StateMatrix (..)
  , StateVector (..)
  , replaceVectorElement
  , replaceVector
  , changeElement
  ) where

import Control.Monad.State

import Numeric.LinearAlgebra.HMatrix hiding (corr)
import qualified Data.Vector as V

test = undefined 

type StateMatrix a = State (Matrix a)
type StateVector a = State (Vector a)
type MatrixIndex   = (Int, Int)

replaceVector :: (Element a) => Int -> Vector a -> StateMatrix a ()
replaceVector i v = state $ \m -> ((), changeVector i v m)

replaceVectorElement :: (Element a) => Int -> a -> StateVector a ()
replaceVectorElement i e = state $ \v -> ((), changeElement i e v)


fromStoAandS :: Matrix Double -> ((), Matrix Double)
fromStoAandS = undefined

stateMatrix :: State (Matrix Double) ()
stateMatrix = state fromStoAandS

changeVector :: (Element a) => Int -> Vector a -> Matrix a -> Matrix a
changeVector i v m = fromRows $ rowsAbove ++ v : rowsBelow
  where
    rowsAbove = toRows $ takeRows (i - 1) m
    rowsBelow = toRows $ dropRows (i + 1) m

changeElement :: (Element a) => Int -> a -> Vector a -> Vector a
changeElement i e v = fromList $ elemsBefore ++ e : elemsAfter
  where
    elemsBefore = take (i - 1) $ lV
    elemsAfter  = drop (i + 1) $ lV
    lV         = toList v
    
vectorConvert :: V.Vector a -> Vector a
vectorConvert = undefined 
